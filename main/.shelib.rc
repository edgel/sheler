###############################################################################
#!/bin/bash
# 
# Shell Library ($sh), a simple shell library for the bash scripts.
# 
# Version: 1.2
# 
# Public Varibles:
#   SHELIB_SHOW_TRACE; 
# 
# Public Methods:
#   $sh debug <msg> | info <msg> | warn <msg> | error <msg>;
#   $sh enable <debug | info | warn | error>;
#   $sh disable <debug | info | warn | error>;
# 
#   $sh exec <-e|-l|-d> <command>;
#   $sh fman -rm|-ls|-cp|-mv|-ln <folder> <filename-pattern>;
#   $sh fref -d <ref-path> | -f <ref-path> | -n <ref-path> | -p <ref-path>;
# 
#   $sh steps (<step-name:id>)*;
#   $sh step -s | -d | <step-name> [step-id];
#   $sh done -p [shell-path] | -c [shell-path] | -r [shell-path] <step-id>;
# 
#   $sh expect <timeout-in-seconds> <script-path> (<prompt> <value>)+;
#   $sh ssh -keygen | -auth | -agent | -keyadd | -know [id] [host];
#   $sh scp -|<owner> <''|.tar|.tgz|.tar.gz|.zip> <name> <from> <to>;
# 
# Private Varibles:
#   _SHELIB_SHOW_<DEBUG|INFO|WARN|ERROR>;
#   _SHELIB_SREF_PATH; 
#   _SHELIB_DREF_PATH;
#   _SHELIB_CURR_STEP;
# 
# Private Methods:
#   _shelib_trace; _shelib_logf; _shelib_4tee;
# 
# Releated Files:
#   $_SHELIB_SREF_PATH.log
#   $_SHELIB_SREF_PATH.lgx
#   $_SHELIB_DREF_PATH.sdf
# 
#   $_SHELIB_SREF_PATH.lgr
#   $_SHELIB_DREF_PATH.tmp
# 
# Dependencies: 
#   echo, pwd, ls, cat, grep, cut, sed, date, rm, mkdir, chown, dirname, 
#   filename, tar, zip, unzip, eval, xargs, ssh, scp, expect

###############################################################################

shelib(){
  if [ ! -z "$2" ] ; then
    shelib_$1 "${@:2}"; # exec the shelib methods
  fi
}

if [ ! -z "$sh" ] ; then
  _sh=$sh; _shelib_trace "Var _sh vs sh: [$_sh, $sh]";
fi

sh=shelib; # define $sh as the short func name

###############################################################################

_shelib_trace(){
  if [ "$SHELIB_SHOW_TRACE" == "true" ] ; then
    if [ "-e" != "$1" ] ; then
      echo ">> $@"
    else
      echo -e ">> ${@:2}"
    fi
  fi
}

_shelib_logf(){
  if [ "-e" != "$1" ] ; then
    echo "$(date +%Y-%m-%d' '%H:%M:%S.%N) [$0] $@"
  else
    echo -e "$(date +%Y-%m-%d' '%H:%M:%S.%N) [$0] ${@:2}"
  fi
}

shelib_debug(){
  if [ "$_SHELIB_SHOW_DEBUG" == "true" ] ; then
    _shelib_logf [DEBUG] $@;
  fi
}

shelib_info(){
  if [ "$_SHELIB_SHOW_INFO" != "false" ] ; then
    _shelib_logf [INFO] $@;
  fi
}

shelib_warn(){
  if [ "$_SHELIB_SHOW_WARN" != "false" ] ; then
    _shelib_logf [WARN] $@;
  fi
}

shelib_error(){
  if [ "$_SHELIB_SHOW_ERROR" != "false" ] ; then
    _shelib_logf [ERROR] $@;
  fi
}

shelib_enable(){
  export _SHELIB_SHOW_$1="true";
}

shelib_disable(){
  export _SHELIB_SHOW_$1="false";
}

###############################################################################

shelib_exec(){
  if [ "-e" == "$1" ] ; then
    "${@:2}"; _result=$?;
  elif [ "-l" == "$1" ] ; then
    if [ -f $_SHELIB_SREF_PATH.log ] ; then
      ( echo -e "\n--\n" && cat $_SHELIB_SREF_PATH.log ) >> $_SHELIB_SREF_PATH.lgx;
    fi
    _shelib_4tee $_SHELIB_SREF_PATH.lgr "${@:2}" 2>&1 | tee $_SHELIB_SREF_PATH.log; 
    _result=$(cat $_SHELIB_SREF_PATH.lgr; rm -f $_SHELIB_SREF_PATH.lgr);
  elif [ "-d" == "$1" ] ; then
    if [ -f $_SHELIB_SREF_PATH.log ] ; then
      ( echo -e "\n--\n" && cat $_SHELIB_SREF_PATH.log ) >> $_SHELIB_SREF_PATH.lgx;
    fi
    # PS4 Other Options: ${SHLVL},${BASH_SUBSHELL} $@ $? $1 \t
    set -x; PS4='	| ${BASH_SOURCE} ${LINENO} ${FUNCNAME}() ' \
    _shelib_4tee $_SHELIB_SREF_PATH.lgr "${@:2}" 2>&1 | tee $_SHELIB_SREF_PATH.log;
    _result=$(cat $_SHELIB_SREF_PATH.lgr; rm -f $_SHELIB_SREF_PATH.lgr);
  fi
  _shelib_trace "The command exec result: $_result"; if [ "0" != "$_result" ] ; then
    exit $_result;
  fi
}

_shelib_4tee(){
  "${@:2}"; echo $? > $1; # shelib__exec <result-file> <command>
}

shelib_fman(){
  if [ "$1" == "-rm" ] ; then
    find $2 -name "$3" | xargs rm -f;
  elif [ "$1" == "-ls" ] ; then
    find $2 -name "$3" | xargs ls -l;
  elif [ "$1" == "-cp" ] ; then
    find $2 -name "$3" | cp -t $4;
  elif [ "$1" == "-mv" ] ; then
    find $2 -name "$3" | mv -t $4;
  elif [ "$1" == "-ln" ] ; then
    find $2 -name "$3" | ln -s -t $4;
  fi
}

shelib_fref(){
  _filepath=$2; # def file path
  if [ -z "$_filepath" ] ; then
    _filepath=$0;
  fi
  if [ "$1" == "-d" ] ; then
    dirname `pwd`/$_filepath;
  elif [ "$1" == "-f" ] ; then
    basename $_filepath;
  elif [ "$1" == "-n" ] ; then
    _file=$(shelib_fref -f $2); echo ${_file%.*};
  elif [ "$1" == "-r" ] ; then
    echo $(shelib_fref -d $2)/$(shelib_fref -n $2);
  fi
}

{ # init _SHELIB_SREF_PATH
  _shelib_trace "Current invoker folder: $(shelib_fref -d), filename: $(shelib_fref -n), args: [$@]"
  _SHELIB_SREF_PATH=$(shelib_fref -r); _shelib_trace "Init the script refer path: $_SHELIB_SREF_PATH";
  if [ ! -d "$(dirname $_SHELIB_SREF_PATH)" ] ; then
    _shelib_trace "Create dir $(dirname $_SHELIB_SREF_PATH)"; mkdir -p $(dirname $_SHELIB_SREF_PATH);
  fi
}

#count file num: num=$(ls $_SHELIB_SREF_PATH.log* | wc -l)

###############################################################################

shelib_steps(){
  _user_steps=$@; # def the user steps to exec
  if [ $# -eq 1 ] ; then
    _user_steps=`eval echo $1`;
  elif [ $# -gt 1 ] ; then
    if [ "`eval echo $1`" != "$1" ] ; then
      _user_steps=`eval echo ${@:2}`;
    fi
  fi
  for _step_id in $_user_steps ; do
    _step_name=$(echo $_step_id|cut -d : -f 1);
    shelib_step $_step_name $_step_id; 
  done
}

shelib_step(){
  if [ $1 == '-s' ] ; then
    _history=$(cat $(echo $_SHELIB_DREF_PATH.sdf) | grep "^$(echo $_SHELIB_CURR_STEP) done at ");
    if [ ! -z "$_history" ] ; then
      _shelib_trace Skip step $_SHELIB_CURR_STEP;
      echo $_SHELIB_CURR_STEP skip at $(date +%Y-%m-%d' '%H:%M:%S.%N) >> $_SHELIB_DREF_PATH.sdf
      return 1;
    fi
    _history=$(cat $(echo $_SHELIB_DREF_PATH.sdf) | grep "^$(echo $_SHELIB_CURR_STEP) start at ");
    if [ ! -z "$_history" ] ; then
      _shelib_trace Resume step $_SHELIB_CURR_STEP ...;
      echo $_SHELIB_CURR_STEP resume at $(date +%Y-%m-%d' '%H:%M:%S.%N) >> $_SHELIB_DREF_PATH.sdf
      return 0;
    fi
    _shelib_trace Start step $_SHELIB_CURR_STEP ...;
    echo $_SHELIB_CURR_STEP start at $(date +%Y-%m-%d' '%H:%M:%S.%N) >> $_SHELIB_DREF_PATH.sdf

  elif [ $1 == '-d' ] ; then
    _history=$(cat $(echo $_SHELIB_DREF_PATH.sdf) | grep "^$(echo $_SHELIB_CURR_STEP) quit at ");
    if [ ! -z "$_history" ] ; then
      return 0;
    fi
    _result_curr_step=$2;
    if [ $_result_curr_step -ne 0 ] ; then
      exit $_result_curr_step;
    fi
    _shelib_trace Done step $_SHELIB_CURR_STEP;
    echo $_SHELIB_CURR_STEP done at $(date +%Y-%m-%d' '%H:%M:%S.%N) >> $_SHELIB_DREF_PATH.sdf

  elif [ $1 == '-q' ] ; then
    _result_curr_step=$2;
    if [ $_result_curr_step -ne 0 ] ; then
      exit $_result_curr_step;
    fi
    _shelib_trace Quit step $_SHELIB_CURR_STEP;
    echo $_SHELIB_CURR_STEP quit at $(date +%Y-%m-%d' '%H:%M:%S.%N) >> $_SHELIB_DREF_PATH.sdf

  else  
    _name_curr_step=$1; _SHELIB_CURR_STEP=$2; 
    if [ -z "$_SHELIB_CURR_STEP" ] ; then
      _SHELIB_CURR_STEP=$_name_curr_step;
    fi
    _shelib_trace "-----------------------------------------------------------------------------";
    _shelib_trace "-- Exec step { name: $_name_curr_step, id: $_SHELIB_CURR_STEP }";
    _shelib_trace "-- ";
    shelib_step -s;
    if [ $? -eq 0 ] ; then
      $_name_curr_step; shelib_step -d $?;
    fi
  fi
}

shelib_done(){
  if [ "$1" == "-p" ] ; then # clean
    echo ~/.shelib$(shelib_fref -r $2); # return step done refer path of the script
  elif [ "$1" == "-c" ] ; then # clean
    _shelib_trace "Clean done files for $2";
    shelib_fman -rm "$(dirname `shelib_done -p $2`)" "*.sdf";
  elif [ "$1" == "-r" ] ; then # reset
    _shelib_trace "Reset steps: ${@:3} for script: $2";
    for _step_id in "${@:3}" ; do
      _dref_path=$(shelib_done -p $2);
      _shelib_trace "Reset step: $_step_id in $_dref_path.sdf"; 
      cat $_dref_path.sdf > $_dref_path.tmp \
      && sed "s/^$_step_id done at /$_step_id ---- at /g" $_dref_path.tmp > $_dref_path.sdf \
      && rm $_dref_path.tmp;
      _shelib_trace "Reset step: $_step_id done with $?"; 
    done
  fi
}

{ # init _SHELIB_DREF_PATH
  _SHELIB_DREF_PATH=$(shelib_done -p); _shelib_trace "Init the done refer path: $_SHELIB_DREF_PATH";
  if [ ! -f "$_SHELIB_DREF_PATH.sdf" ] ; then
    _shelib_trace "Create file $(basename $_SHELIB_DREF_PATH.sdf) in dir $(dirname $_SHELIB_DREF_PATH.sdf)";
    mkdir -p $(dirname $_SHELIB_DREF_PATH.sdf) && > $_SHELIB_DREF_PATH.sdf;
  fi
}

###############################################################################
# The expect Format:
# $sh expect <timeout-in-seconds> "<command>" ( <prompt> <value> )+
# 
# Example:
# $sh expect 1 "./expect.sh -r" "username :" u "password:" p

shelib_expect(){
  _script=( $2 ); if [ -z "$_script" ] ; then
    return 1;
  fi

  _exp="set timeout $1; spawn bash $_script; expect {"
  for (( i=3;i<$#;i=i+2 )) ; do
    _prompt="${@:i:1}"; _value="${@:i+1:1}";
    _exp="$_exp\n  \"$_prompt\" {send \"$_value\\\\r\"; exp_continue;}"
  done
  _exp="$_exp\n  eof {}" # send_user \">> End with eof\\\\n\";
  _exp="$_exp\n  timeout {send_user \">> End with timeout\\\\n\";exit 1;}" 
  _exp="$_exp\n}"

  _shelib_trace -e "Exec: expect << __EOF\n"$_exp"\n__EOF"; expect << __EOF; # 
    $(echo -e $_exp); 
__EOF
}

###############################################################################
# The ssh Format:
# $sh ssh -keygen <id>;
# $sh ssh -auth <id.pub> <user@host>;
# $sh ssh -agent [agent-id] | -keyadd <id> | -know <id> <user@host>;
# 
# Example:
# $sh ssh -g id;
# $sh ssh -auth id root@hostname;
# $sh ssh -agent /tmp/ssh-*/agent.* | -keyadd id | -know id root@hostname;
# 
# References:
# - http://docs.oracle.com/cd/E19253-01/816-4557/sshuser-33/index.html
# ssh-keygen # -t rsa -f id
# ssh-agent # eval `ssh-agent`
# ssh-add # ssh-add -L | id
# ssh server-host # for client-side ~/.ssh/known_hosts
# ssh-copy-id -i ~/.ssh/id_rsa.pub server-host # for server-side ~/.ssh/authorized_keys

shelib_ssh(){
  if [ "-keygen" == "$1" ] ; then 
    ssh-keygen -t rsa -f $2;
    #Enter passphrase (empty for no passphrase):
    #Enter same passphrase again:
  elif [ "-auth" == "$1" ] ; then 
    ssh-copy-id -i $2 $3;
  elif [ "-agent" == "$1" ] ; then
    if [ -z "$2" ] ; then
      eval `ssh-agent`;
    else
      export SSH_AUTH_SOCK=$2;
    fi
  elif [ "-keyadd" == "$1" ] ; then 
    ssh-add $2; ssh-add -L;
    #Enter passphrase for id:
  elif [ "-know" == "$1" ] ; then 
    ssh -i $2 $3;
    #Are you sure you want to continue connecting (yes/no)?
    #root@hostname's password:
  fi
}

###############################################################################
# The scp Format:
# $sh scp -|<owner> <''|.tar|.tgz|.zip|...> <filename> <from> <to>
# 
# Example:
# $sh scp ora112:dba .tar oracle11g ora112@hostname:/data/oracle /tmp/db

shelib_scp(){
  if [ $# -ne 5 ] ; then 
    return 1;
  fi

  _shelib_trace "Add owner:$1,type=$2,name=$3,file=$3$2,from=$4/,to=$5/";
  _owner=$1; _type=$2; _name=$3; _file=$3$2; _from=$4/; _to=$5/;

  mkdir -p $_to; scp -i ~/.ssh/id_rsa $_from$_file $_to;
  if [ $? -ne 0 ] ; then
    return 2;
  fi

  if [ "$_type" == ".zip" ] ; then
    _shelib_trace "Unzip file $_file"; cd $_to && unzip $_file && rm -f $_file; cd -;
  elif [ "$_type" == ".tar" ] ; then
    _shelib_trace "Untar file $_file"; cd $_to && tar xvf $_file && rm -f $_file; cd -;
  elif [ "$_type" == ".tgz" ] || [ "$_type" == ".tar.gz" ] ; then
    _shelib_trace "Untar file $_file"; cd $_to && tar xzvf $_file && rm -f $_file; cd -;
  fi

  if [ "$_owner" != "-" ] ; then
    _shelib_trace "Chang owner to $_owner for $_to$_name";
    chown -R $_owner $_to$_name;
  fi
  ls -l $_to; _shelib_trace "Add done for file $_file";
}

###############################################################################
